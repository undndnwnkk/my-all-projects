# Лабораторная работа №2 (bigint)

## Содержание

1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Советы](#советы)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Дополнительные требования](#дополнительные-требования)
    1. [Частичные решения](#частичные-решения)
1. [Инструкция по сдаче](#инструкция-по-сдаче)
1. [Система оценки](#система-оценки)
1. [Сроки сдачи](#сроки-сдачи)

## Задание

Реализуйте «длинную арифметику», то есть класс (структуру), хранящий внутри себя числа произвольной длины и поддерживающий базовые арифметические операции с ними.
Внутри класса число хранится как последовательность цифр, каждая цифра — от 0 до `BASE - 1`, где `BASE` — глобальная константа-степень десятки.
Для упрощения реализации, нужно поддержать только беззнаковую целочисленную арифметику, то есть поддерживаются только неотрицательные числа.
Чем-то похоже на упрощённую версию `cpp_int` из Boost.Multiprecision, можете глянуть секцию "Example" [тут](https://www.boost.org/doc/libs/1_80_0/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html).

Решение должно быть оформлено в виде класса `bigint` внутри пространства имён `lab_bigint`.
Вы можете реализовать только часть операций или пользоваться дополнительными предположениями, смотри [частичные решения](#частичные-решения).

Для удобства работы и тестирования `bigint` должен уметь конструироваться из строки и из числа типа `unsigned int`. Весь остальной зоопарк целочисленных типов можно не реализовывать.

```C++
bigint x("179"), y(57);  // Создаёт числа 179 и 57, соответственно.
```

Числа нужно уметь сравнивать между собой, а также с числами типа `unsigned int`. Можно не поддерживать другие целочисленные типы, в том числе `int` и `unsigned long long`.

```C++
bigint x("179"), y("57");
std::cout << std::boolalpha
          << (x == y) << " "
          << (x != 57) << " "
          << (179 < y) << " "
          << (y >= x) << std::endl;  // Должен вывести "false true false false".
```

Из простых арифметических действий требуется поддерживать только сложение и вычитание. Можно считать, что в случае, если в результате вычитания получаются отрицательные числа, поведение неопределено (т.е. гарантируется, что в тестах такого не бывает). Точно так же нужно уметь складывать и вычитать с `unsigned int`.

```C++
bigint x("179"), y("57");
std::cout << std::boolalpha
          << (x + y == bigint("236")) << " "
          << (x - 57 == bigint("122")) << " "
          << (200 - x == bigint("21")) << std::endl;  // Должен вывести "true trtue true".
```

Кроме того, нужно поддерживать операторы присваивания, в том числе `+=` и `-=`, в том числе с аргументами типа `unsigned int`.

```C++
bigint x("179"), y("57");
x += y;
x -= 57;
y += 122;
std::cout << std::boolalpha << (x == y) << std::endl;  // Должен вывести "true".
```

Также требуется поддерживать постфиксные и префиксные инкременты и декременты (все четыре комбинации).

```C++
bigint x("179");
x++;
++x;
x--;
--x;
std::cout << std::boolalpha << (x == 179) << std::endl; // Должен вывести "true".
```

Также нужно уметь поддерживать преобразование `bigint` в строки (для чего нужно реализовать метод `to_string()`, возвращающий `std::string`), ввод и вывод. При реализации ввода можно рассчитывать на то, что ввод всегда будет корректный (то есть гарантируется, что в тестах не бывает иначе).

```C++
bigint x("179");
std::cout << x.to_string() << std::endl;  // Должен вывести "179" (без кавычек).
std::cout << x << std::endl;  // Должен вывести "179" (без кавычек).
bigint y;
std::cin >> y;  // Должен прочитать число со стандартного ввода.
```

### Советы
* Прочитайте и поймите происходящее в тестах _перед тем_ как писать решение.
* При реализации всегда помните про ведущие нули.
  Сразу придумайте инвариант.
* Если вы в программе где-то написали числовой литерал (вроде `0x123`), то вы не можете узнать, как именно он был написан, это не требуется.
  Число есть число, его обработает компилятор и даст вам число, с котором можно делать арифметические операции.
* Храните цифры в векторе, а не строчке — так и проще поддержать произвольное основание системы счисления, и в коде меньше лишних операций вроде `- '0'` и `+ '0'`.
* Возможно, для реализации сложения и вычитания в столбик окажется проще хранить числа в перевёрнутом виде (то есть первый элемент вектора — младшая цифра числа).
* Реализуйте симметричные бинарные операторы вроде `+` и `==` как функции вне класса, а не как методы.
    * В таком случае при наличии конструктора от `unsigned int` при вызове `2 + bigint("123")` сработает неявное преобразование и перегрузка `operator+(const bigint&, const bigint&)` подойдёт.
    * Это позволяет избежать дублирования кода: вам будет достаточно реализовать `+` и `==` по одному разу, а не для каждой комбинации `bigint`/`unsigned int`
    * При необходимости пользуйтесь `friend`.
* Если у вас неоднозначная (ambiguous) перегрузка в выражении вроде `bigint(10) == 10`, то, скорее всего, у вас есть
  и неявное преобразование из `int` в `bigint`, и наоборот.
  И компилятор не знает, что сделать.
  Подумайте, так ли уж нужны эти неявные преобразования, перечитайте дополнительные требования.
    * Extra reading: а вот если бы у нас были не типы `bigint`/`int`,
      а с типами `bigint`/`std::string`, то неоднозначности бы не было,
      потому что неявное преобразование к `std::string` не выполнилось бы,
      [потому что `std::string` — шаблон (template)](https://stackoverflow.com/a/7505108/767632).
* Реализовывать `operator=` не надо — в правильной реализации вас устроит его стандартное поведение: переприсвоивать каждое поле по отдельности.
    * А конструкции вида `a = 10` должны успешно работать через неявное преобразование числа к `bigint` через неявный конструктор.
* Чтобы посчитать длину `int` в десятичных символах, можно преобразовать его к строке и взять длину.
  В том числе при вычислении константы.
* Если у вас возникают проблемы с алгоритмической частью (сложение, вычитание) — обращайтесь к практикам по C++ или алгоритмам.
* Если вы заведёте константное поле — станет невозможно копировать объекты, отключится `operator=`.
  Константы лучше делать статическими.
* cppcheck иногда может зря ругаться на отсутствие `explicit` у конструктора.
  Тогда можно заглушить это предупреждение.
* Вам может быть интересно прочитать [наивную реализацию и комментарии к ней](https://habr.com/ru/company/ruvds/blog/576716/).
  Например, она работает только с `BASE == 10` (потому что хранит цифры в строке), поддерживает не нужные нам отрицательные числа,
  использует исключения (у нас некорректная операция - это просто UB), и имеет кучу стилистических проблем.
  Комментарии могут быть противоречивыми, это нормально, у программистов разные стили.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/).

Программа должна занимать не более 300 строк.
Официальное решение занимает 195 строк.

Обратите внимание, что теперь требуется скомпилировать два файла за одну команду: `bigint_test.cpp` и `doctest_main.cpp`,
а вот `bigint.inc.cpp` туда включать не надо.
Просто передайте оба файла компилятору.

* Для GCC/Clang/MSVC команда выглядит примерно так: `g++ bigint_test.cpp doctest_main.cpp -o bigint_test`
* Для CMake строчка `add_executable(bigint_test bigint_test.cpp)` превращается в `add_executable(bigint_test bigint_test.cpp doctest_main.cpp)`

Также начиная с этого задания следует помечать некоторые функции `[[nodiscard]]`, а некоторые конструкторы и операторы преобразования — `explicit`.

### Дополнительные требования
* Длинное число должно храниться в динамическом массиве по цифрам в системе счисления
  с основанием `BASE`.
  * Константа `BASE` задаётся тестами перед тем как включать ваше решение при помощи `#include`.
  * `BASE` всегда является степенью десятки, строго большей единицы.
  * Гарантируется, что числа `-2 * BASE` и `2 * BASE` помещаются в `int`.
  * Значение `BASE` не влияет на ввод и вывод: они всегда десятичные.
    То есть при изменении `BASE` тесты менять не нужно.
    Например, при `BASE == 1000` конструктор `bigint(12345678)`
    создаёт `bigint` с цифрами `12`, `345`, `678` (в каком-то порядке на ваше усмотрение),
    а при `BASE == 10` — все восемь десятичных цифр отдельно.
    При выводе или преобразовании `bigint` в строку или число снова получается `12345678`.
  * Ваше решение должно автоматически подстраиваться, если изменить только `BASE`.
    В частности, нельзя создавать другие константы, которые надо вручную изменить при изменении `BASE`.
* Требуется аккуратно подумать про (не)явность каждого конструктора и оператора преобразования.
  Делайте его неявным только если он вообще всегда корректен, даже вне рамок этого задания.
  Как будто бы вы пишите библиотеку.
  Например, любой `unsigned int` является корректным `bigint`, но обратное неверно.
  Также не любая строчка является корректным `bigint` в общем случае (хотя в задании это гарантируется).
* Семантика всех операций должна быть как можно ближе к `unsigned int`.
  * Единственное исключение: операция `(a++) = 10` допустима.
    Так проще написать корректный код.
    Такая операция увеличивает `a`, возвращает старое значение `a` и пытается записать в _старое значение_ `a` число `10`.
    Это бессмысленная операция: например, для встроенных типов вроде `int` такой код компилироваться не будет.
    Но в вашем решении такой код автоматически будет компилироваться, запрещать это мы пока не умеем.
* Поведение при некорректных операциях не определено.
  Например, если в результате должно получиться отрицательное число.
  * Не надо нарочно вызвать UB, но вы можете просто про такие случаи не думать.
  * Другими словами, гарантируется, что все операции с `bigint` корректны.
* Каждая операция с числом должна быть как можно эффективнее: сначала важна асимптотика,
  потом важно количество (пере)выделений памяти (в том числе внутри `vector`, `string`, `stringstream`), затем всё остальное.
  * При этом считаем, что выделение вектора размера O(1) бесплатно.
    Этого можно добиться при помощи [boost::small_vector](https://www.boost.org/doc/libs/1_77_0/doc/html/boost/container/small_vector.html) или его аналога вместо `std::vector`,
    но вам это делать не требуется.
  * Также важно аккуратно поставить `break` во всех операциях.
    Например, если вы сделали N операций `a++`, они должны в среднем отработать за `O(n)`, а не за `O(n log n)`.
* Считайте, что ввод всегда корректен и число отделено пробельными символами или концом потока.
  Иначе придётся аккуратно эмулировать семантику `int`, считывать почти посимвольно,
  разбираться с обработкой ошибок ввода, [`sentry`-объектом](https://en.cppreference.com/w/cpp/io/basic_istream/sentry),
  и [багами в стандарте](https://github.com/tardate/LittleCodingKata/blob/main/cpp/DoubleTrouble/README.md).
  Это муторно и специфично, хотя и необходимо для корректной перегрузки.
* Перегрузки `operator>>` и `operator<<` принимают слева и возвращают не `std::stringstream&`,
  а `std::istream&` (для чтения) и `std::ostream&` (для вывода).
  Эти типы — обобщение всех потоков вводы/вывода, соответственно.
  Extra reading: [баг то ли в компиляторе, то ли на cppreference](https://stackoverflow.com/questions/69320918/why-does-taking-istream-to-a-temporary-stringstream-works-but-not-when-tak).

### Частичные решения
Вы можете реализовать любой префикс из шести подзаданий ниже и получить частичные баллы.

Если ваше решения не работает при `BASE != 10`, вы получаете не больше половины баллов.
Если ваше решение ломается при появлении ведущих нулей, а они разрешены, то вы получаете не больше половины баллов.
Акции объединяются: если решение не работает ни с `BASE != 10`, ни с ведущими нулями, вы не можете получить за задание больше 2.5/10.

1. Реализуйте:
    * Конструктор `bigint` по умолчанию (инициализирует в ноль).
    * Конструирование `bigint` от непустой строки из цифр и от `unsigned int`.
      Ведущие нули запрещены, кроме строки `"0"`.
    * Шесть операторов для сравнения чисел.
      Должны работать в том числе в выражениях со смешением `bigint` и `unsigned int`.
    * Метод `to_string()`, преобразовывающий число в строку.
1. Реализуйте оператор явного (explicit) преобразования в `unsigned int`.
   Также с этого момента разрешаются ведущие нули во входных данных, в выходных данных ведущие нули запрещены.
1. Реализуйте операторы `+` и `+=`.
1. Реализуйте операторы `-` и `-=`.
1. Реализуйте постфиксные и префиксные унарные операторы `++` и `--`.
1. Реализуйте операторы `<<` и `>>` для ввода-вывода.

## Инструкция по сдаче
[Схема стандартная](../common/#формат-сдачи): вы должны выполнить
задание в отдельной ветке своего существующего закрытого репозитория в организации и в нём же создать Pull Request.
Никаких форков!
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания, закомментируйте строки вида `#define TEST_9`
для остальных частей в файле `bigint_test.cpp`, чтобы отключить соответствующие автотесты.
Строк столько же, сколько частей задания.

## Система оценки
[Схема стандартная](../common/#система-оценки), баллы:

|Выполненные части|Макс. корректность|Макс. стиль|Макс. итог|
|---|---|---|---|
|1  |1  |1  | 2|
|1-2|1.5|1.5| 3|
|1-3|2.5|2.5| 5|
|1-4|3.5|3  | 7|
|1-5|5  |4  | 9|
|1-6|6  |4  |10|

## Сроки сдачи
Задание выдано 9 октября 2024 (среда).
Ниже в каждом случае указано московское время.

* **Дедлайн сдачи:** 20 октября 2024 (воскресенье), **22**:59.
* Ожидаемый срок проверки: 3 ноября 2024 (воскресенье), сразу после конца сессии.
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
    * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
    * Выставляется максимум из всех попыток.
* **Срок исправлений**: 10 ноября 2024 (воскресенье), **22**:59.
